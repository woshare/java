# 开发经验之谈

## 缓存
>1，「缓存穿透」指的是请求不存在的数据，从而使得缓存形同虚设，缓存层被穿透了。例如我们请求一个 UserID 为 -1 的用户数据，因为该用户不存在，所以该请求每次都会去读取数据库。在这种情况下，如果某些心怀不轨的人利用这个存在的漏洞去伪造大量的请求，那么很可能导致DB承受不了那么大的流量就挂掉了。**解决方案，一种是事前预防，一种是事后预防**
>2，「缓存击穿」指的是并发量很高的 KEY，在该 KEY 失效的瞬间有很多请求同同时去请求数据库，更新缓存。例如我们有一个业务 KEY，该 KEY 的并发请求量为 10000。当该 KEY 失效的时候，就会有 1 万个线程会去请求数据库更新缓存。这个时候如果没有采取适当的措施，那么数据库很可能崩溃。**解决方案，一种是互斥锁，一种是永远不过期。**
>3，「缓存雪崩」则是指缓存在同一时间同时过期，就像所有雪块同一时刻掉下来，像雪崩一样。例如我们有 1000 个KEY，而每个 KEY 的并发请求不大，只有 10 次。而缓存雪崩指的就是这 1000 个 KEY 在同一时间，同时失效，这个时候就突然有 1000 ** 10 = 一万次查询。**最简单的方案就是在原有失效时间的基础上增加一个随机时间（例如1-5分钟）**
>4，总而言之，「缓存穿透」是业务层面的漏洞导致非法请求，与请求量、缓存失效没关系。「缓存击穿」则只会出现在热点数据上，发生在缓存失效的瞬间，与业务没多大关系。「缓存雪崩」则是因为多个 KEY 同时失效，导致数据库请求太多。非热点数据也会导致缓存雪崩，只要同时失效的 KEY 足够多   


## Java&JVM定位问题

###确认是不是内存本身就分配过小
>1，jmap -heap 31223

### 找到最耗内存的对象：执行该命令会强制执行一次fgc。另外还可以dump内存进行分析
>1，jmap -histo:live 31223|more


### 确认是否是资源耗尽：查看进程创建的线程数，以及网络连接数，如果资源耗尽，也可能出现OOM
>1，pstree
>2，netstat
>3，/proc/${PID}/fd
>4，/proc/${PID}/task

### 命名规范
>1，类名大驼峰，方法名，参数名，成员变量名，局部变量名等使用小驼峰，常量全大写，‘_’分隔，包名全小写
>2，bool类型变量名，不要前缀is   
>3，


### 异常
* [异常处理经验介绍](https://novoland.github.io/%E8%AE%BE%E8%AE%A1/2015/08/17/%E5%BC%82%E5%B8%B8.html)

##JMX
>1，程序好手则会写一段代码，把配置值缓存起来，系统在获取的时候，**先看看配置文件有没有改动，如有改动则重新从配置里读取，否则从缓存里读取**
>2，程序高手则用JMX把需要配置的属性集中在一个类中，然后写一个MBean，再进行相关配置。另外JMX还提供了一个工具页，以方便我们对参数值进行修改

## 热更新，怎么不影响正在使用的用户

